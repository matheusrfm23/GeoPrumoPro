{"ast":null,"code":"// geoprumo/frontend/src/services/api.js (versão atualizada)\n\nimport axios from 'axios';\nconst apiClient = axios.create({\n  baseURL: 'http://127.0.0.1:8000/api/v1',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// ... (as funções fileToBase64 e optimizeRouteData permanecem as mesmas) ...\nconst fileToBase64 = file => new Promise((resolve, reject) => {\n  const reader = new FileReader();\n  reader.readAsDataURL(file);\n  reader.onload = () => resolve(reader.result.split(',')[1]);\n  reader.onerror = error => reject(error);\n});\nexport const optimizeRouteData = async payload => {\n  const filesAsBase64 = await Promise.all(payload.files.map(async f => ({\n    filename: f.name,\n    content: await fileToBase64(f)\n  })));\n  const requestBody = {\n    files: filesAsBase64,\n    links: payload.links,\n    texts: payload.texts,\n    options: {\n      optimization_mode: 'online'\n    }\n  };\n  try {\n    const response = await apiClient.post('/process/optimize', requestBody);\n    return response.data;\n  } catch (error) {\n    if (error.response) throw new Error(error.response.data.detail || 'Erro no servidor.');\n    if (error.request) throw new Error('Não foi possível se comunicar com o servidor.');\n    throw new Error('Erro ao preparar a requisição.');\n  }\n};\nexport const enrichRouteWithAI = async points => {\n  try {\n    const response = await apiClient.post('/process/enrich-with-ai', {\n      points\n    });\n    return response.data;\n  } catch (error) {\n    if (error.response) throw new Error(error.response.data.detail || 'Erro no servidor de IA.');\n    if (error.request) throw new Error('Não foi possível se comunicar com o servidor de IA.');\n    throw new Error('Erro ao preparar a requisição para IA.');\n  }\n};\n\n/**\r\n * NOVO: Solicita um arquivo de exportação e inicia o download.\r\n */\nexport const exportRouteFile = async (format, points) => {\n  try {\n    const response = await apiClient.post(`/export/${format}`, points, {\n      responseType: 'blob' // Importante: diz ao axios para esperar um arquivo\n    });\n\n    // Cria um link temporário na memória para iniciar o download\n    const url = window.URL.createObjectURL(new Blob([response.data]));\n    const link = document.createElement('a');\n    link.href = url;\n\n    // Extrai o nome do arquivo do cabeçalho da resposta\n    const contentDisposition = response.headers['content-disposition'];\n    let fileName = `rota_otimizada.${format}`;\n    if (contentDisposition) {\n      const fileNameMatch = contentDisposition.match(/filename=\"(.+)\"/);\n      if (fileNameMatch.length === 2) fileName = fileNameMatch[1];\n    }\n    link.setAttribute('download', fileName);\n    document.body.appendChild(link);\n    link.click();\n    link.remove(); // Limpa o link após o download\n  } catch (error) {\n    console.error(`Erro ao exportar para ${format}:`, error);\n    throw new Error(`Não foi possível exportar o arquivo ${format.toUpperCase()}.`);\n  }\n};","map":{"version":3,"names":["axios","apiClient","create","baseURL","headers","fileToBase64","file","Promise","resolve","reject","reader","FileReader","readAsDataURL","onload","result","split","onerror","error","optimizeRouteData","payload","filesAsBase64","all","files","map","f","filename","name","content","requestBody","links","texts","options","optimization_mode","response","post","data","Error","detail","request","enrichRouteWithAI","points","exportRouteFile","format","responseType","url","window","URL","createObjectURL","Blob","link","document","createElement","href","contentDisposition","fileName","fileNameMatch","match","length","setAttribute","body","appendChild","click","remove","console","toUpperCase"],"sources":["C:/Users/mathe/Desktop/GeoPrumoPro/frontend/src/services/api.js"],"sourcesContent":["// geoprumo/frontend/src/services/api.js (versão atualizada)\r\n\r\nimport axios from 'axios';\r\n\r\nconst apiClient = axios.create({\r\n  baseURL: 'http://127.0.0.1:8000/api/v1',\r\n  headers: { 'Content-Type': 'application/json' },\r\n});\r\n\r\n// ... (as funções fileToBase64 e optimizeRouteData permanecem as mesmas) ...\r\nconst fileToBase64 = (file) => new Promise((resolve, reject) => {\r\n  const reader = new FileReader();\r\n  reader.readAsDataURL(file);\r\n  reader.onload = () => resolve(reader.result.split(',')[1]);\r\n  reader.onerror = (error) => reject(error);\r\n});\r\n\r\nexport const optimizeRouteData = async (payload) => {\r\n  const filesAsBase64 = await Promise.all(payload.files.map(async f => ({ filename: f.name, content: await fileToBase64(f) })));\r\n  const requestBody = { files: filesAsBase64, links: payload.links, texts: payload.texts, options: { optimization_mode: 'online' } };\r\n  try {\r\n    const response = await apiClient.post('/process/optimize', requestBody);\r\n    return response.data;\r\n  } catch (error) {\r\n    if (error.response) throw new Error(error.response.data.detail || 'Erro no servidor.');\r\n    if (error.request) throw new Error('Não foi possível se comunicar com o servidor.');\r\n    throw new Error('Erro ao preparar a requisição.');\r\n  }\r\n};\r\n\r\nexport const enrichRouteWithAI = async (points) => {\r\n  try {\r\n    const response = await apiClient.post('/process/enrich-with-ai', { points });\r\n    return response.data;\r\n  } catch (error) {\r\n    if (error.response) throw new Error(error.response.data.detail || 'Erro no servidor de IA.');\r\n    if (error.request) throw new Error('Não foi possível se comunicar com o servidor de IA.');\r\n    throw new Error('Erro ao preparar a requisição para IA.');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * NOVO: Solicita um arquivo de exportação e inicia o download.\r\n */\r\nexport const exportRouteFile = async (format, points) => {\r\n  try {\r\n    const response = await apiClient.post(`/export/${format}`, points, {\r\n      responseType: 'blob', // Importante: diz ao axios para esperar um arquivo\r\n    });\r\n\r\n    // Cria um link temporário na memória para iniciar o download\r\n    const url = window.URL.createObjectURL(new Blob([response.data]));\r\n    const link = document.createElement('a');\r\n    link.href = url;\r\n    \r\n    // Extrai o nome do arquivo do cabeçalho da resposta\r\n    const contentDisposition = response.headers['content-disposition'];\r\n    let fileName = `rota_otimizada.${format}`;\r\n    if (contentDisposition) {\r\n      const fileNameMatch = contentDisposition.match(/filename=\"(.+)\"/);\r\n      if (fileNameMatch.length === 2) fileName = fileNameMatch[1];\r\n    }\r\n    \r\n    link.setAttribute('download', fileName);\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    link.remove(); // Limpa o link após o download\r\n\r\n  } catch (error) {\r\n    console.error(`Erro ao exportar para ${format}:`, error);\r\n    throw new Error(`Não foi possível exportar o arquivo ${format.toUpperCase()}.`);\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}