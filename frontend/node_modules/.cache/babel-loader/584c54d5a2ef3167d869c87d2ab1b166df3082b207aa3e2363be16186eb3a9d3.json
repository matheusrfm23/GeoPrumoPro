{"ast":null,"code":"// geoprumo/frontend/src/services/api.js\n\nimport axios from 'axios';\n\n// Configura a URL base da nossa API.\n// Durante o desenvolvimento, ela aponta para o nosso servidor local do FastAPI.\nconst apiClient = axios.create({\n  baseURL: 'http://127.0.0.1:8000/api/v1',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n/**\r\n * Converte um arquivo (File object) para uma string Base64.\r\n * @param {File} file O arquivo a ser convertido.\r\n * @returns {Promise<string>} Uma promessa que resolve com a string Base64.\r\n */\nconst fileToBase64 = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = () => {\n      // A string resultante é \"data:<mimetype>;base64,<dados>\"\n      // Nós queremos apenas os dados, por isso o split.\n      resolve(reader.result.split(',')[1]);\n    };\n    reader.onerror = error => reject(error);\n  });\n};\n\n/**\r\n * Envia os dados brutos para o backend para análise e otimização.\r\n * @param {object} payload O objeto contendo arquivos, links e textos.\r\n * @returns {Promise<object>} A resposta da API com a rota otimizada.\r\n */\nexport const processRouteData = async payload => {\n  // 1. Converte todos os arquivos para Base64 em paralelo\n  const filesAsBase64 = await Promise.all(payload.files.map(async file => {\n    const content = await fileToBase64(file);\n    return {\n      filename: file.name,\n      content\n    };\n  }));\n\n  // 2. Monta o corpo da requisição final\n  const requestBody = {\n    files: filesAsBase64,\n    links: payload.links,\n    texts: payload.texts,\n    options: {\n      // Por enquanto, as opções são fixas, mas podem vir da UI no futuro\n      optimization_mode: 'online'\n    }\n  };\n\n  // 3. Faz a chamada POST para o nosso backend\n  try {\n    const response = await apiClient.post('/process/analyze-and-optimize', requestBody);\n    return response.data; // Retorna os dados da resposta (rota otimizada, etc.)\n  } catch (error) {\n    // Em caso de erro, lança o erro para o componente tratar\n    if (error.response) {\n      // O backend respondeu com um status de erro (4xx, 5xx)\n      throw new Error(error.response.data.detail || 'Ocorreu um erro no servidor.');\n    } else if (error.request) {\n      // A requisição foi feita, mas não houve resposta (backend fora do ar)\n      throw new Error('Não foi possível se comunicar com o servidor. Ele está online?');\n    } else {\n      // Algum outro erro aconteceu\n      throw new Error('Ocorreu um erro ao preparar a requisição.');\n    }\n  }\n};","map":{"version":3,"names":["axios","apiClient","create","baseURL","headers","fileToBase64","file","Promise","resolve","reject","reader","FileReader","readAsDataURL","onload","result","split","onerror","error","processRouteData","payload","filesAsBase64","all","files","map","content","filename","name","requestBody","links","texts","options","optimization_mode","response","post","data","Error","detail","request"],"sources":["C:/Users/mathe/Desktop/GeoPrumoPro/frontend/src/services/api.js"],"sourcesContent":["// geoprumo/frontend/src/services/api.js\r\n\r\nimport axios from 'axios';\r\n\r\n// Configura a URL base da nossa API.\r\n// Durante o desenvolvimento, ela aponta para o nosso servidor local do FastAPI.\r\nconst apiClient = axios.create({\r\n  baseURL: 'http://127.0.0.1:8000/api/v1',\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  },\r\n});\r\n\r\n/**\r\n * Converte um arquivo (File object) para uma string Base64.\r\n * @param {File} file O arquivo a ser convertido.\r\n * @returns {Promise<string>} Uma promessa que resolve com a string Base64.\r\n */\r\nconst fileToBase64 = (file) => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.readAsDataURL(file);\r\n    reader.onload = () => {\r\n      // A string resultante é \"data:<mimetype>;base64,<dados>\"\r\n      // Nós queremos apenas os dados, por isso o split.\r\n      resolve(reader.result.split(',')[1]);\r\n    };\r\n    reader.onerror = (error) => reject(error);\r\n  });\r\n};\r\n\r\n/**\r\n * Envia os dados brutos para o backend para análise e otimização.\r\n * @param {object} payload O objeto contendo arquivos, links e textos.\r\n * @returns {Promise<object>} A resposta da API com a rota otimizada.\r\n */\r\nexport const processRouteData = async (payload) => {\r\n  // 1. Converte todos os arquivos para Base64 em paralelo\r\n  const filesAsBase64 = await Promise.all(\r\n    payload.files.map(async (file) => {\r\n      const content = await fileToBase64(file);\r\n      return { filename: file.name, content };\r\n    })\r\n  );\r\n\r\n  // 2. Monta o corpo da requisição final\r\n  const requestBody = {\r\n    files: filesAsBase64,\r\n    links: payload.links,\r\n    texts: payload.texts,\r\n    options: {\r\n      // Por enquanto, as opções são fixas, mas podem vir da UI no futuro\r\n      optimization_mode: 'online',\r\n    },\r\n  };\r\n\r\n  // 3. Faz a chamada POST para o nosso backend\r\n  try {\r\n    const response = await apiClient.post('/process/analyze-and-optimize', requestBody);\r\n    return response.data; // Retorna os dados da resposta (rota otimizada, etc.)\r\n  } catch (error) {\r\n    // Em caso de erro, lança o erro para o componente tratar\r\n    if (error.response) {\r\n      // O backend respondeu com um status de erro (4xx, 5xx)\r\n      throw new Error(error.response.data.detail || 'Ocorreu um erro no servidor.');\r\n    } else if (error.request) {\r\n      // A requisição foi feita, mas não houve resposta (backend fora do ar)\r\n      throw new Error('Não foi possível se comunicar com o servidor. Ele está online?');\r\n    } else {\r\n      // Algum outro erro aconteceu\r\n      throw new Error('Ocorreu um erro ao preparar a requisição.');\r\n    }\r\n  }\r\n};"],"mappings":"AAAA;;AAEA,OAAOA,KAAK,MAAM,OAAO;;AAEzB;AACA;AACA,MAAMC,SAAS,GAAGD,KAAK,CAACE,MAAM,CAAC;EAC7BC,OAAO,EAAE,8BAA8B;EACvCC,OAAO,EAAE;IACP,cAAc,EAAE;EAClB;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAIC,IAAI,IAAK;EAC7B,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;IAC/BD,MAAM,CAACE,aAAa,CAACN,IAAI,CAAC;IAC1BI,MAAM,CAACG,MAAM,GAAG,MAAM;MACpB;MACA;MACAL,OAAO,CAACE,MAAM,CAACI,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,CAAC;IACDL,MAAM,CAACM,OAAO,GAAIC,KAAK,IAAKR,MAAM,CAACQ,KAAK,CAAC;EAC3C,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAG,MAAOC,OAAO,IAAK;EACjD;EACA,MAAMC,aAAa,GAAG,MAAMb,OAAO,CAACc,GAAG,CACrCF,OAAO,CAACG,KAAK,CAACC,GAAG,CAAC,MAAOjB,IAAI,IAAK;IAChC,MAAMkB,OAAO,GAAG,MAAMnB,YAAY,CAACC,IAAI,CAAC;IACxC,OAAO;MAAEmB,QAAQ,EAAEnB,IAAI,CAACoB,IAAI;MAAEF;IAAQ,CAAC;EACzC,CAAC,CACH,CAAC;;EAED;EACA,MAAMG,WAAW,GAAG;IAClBL,KAAK,EAAEF,aAAa;IACpBQ,KAAK,EAAET,OAAO,CAACS,KAAK;IACpBC,KAAK,EAAEV,OAAO,CAACU,KAAK;IACpBC,OAAO,EAAE;MACP;MACAC,iBAAiB,EAAE;IACrB;EACF,CAAC;;EAED;EACA,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAM/B,SAAS,CAACgC,IAAI,CAAC,+BAA+B,EAAEN,WAAW,CAAC;IACnF,OAAOK,QAAQ,CAACE,IAAI,CAAC,CAAC;EACxB,CAAC,CAAC,OAAOjB,KAAK,EAAE;IACd;IACA,IAAIA,KAAK,CAACe,QAAQ,EAAE;MAClB;MACA,MAAM,IAAIG,KAAK,CAAClB,KAAK,CAACe,QAAQ,CAACE,IAAI,CAACE,MAAM,IAAI,8BAA8B,CAAC;IAC/E,CAAC,MAAM,IAAInB,KAAK,CAACoB,OAAO,EAAE;MACxB;MACA,MAAM,IAAIF,KAAK,CAAC,gEAAgE,CAAC;IACnF,CAAC,MAAM;MACL;MACA,MAAM,IAAIA,KAAK,CAAC,2CAA2C,CAAC;IAC9D;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}